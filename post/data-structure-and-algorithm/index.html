<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="google-site-verification" content="Wp3QtEkIlF0ZvtKx90lPmoXyH39d-pmBhiTyTbba9L4" />
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta itemprop="name" content="重学数据结构和算法">
<meta itemprop="description" content="常见数据结构 数组 数组的时间效率很高，但是空间效率很低，而且不安全，比如访问越界造成踩内存。 很多高级语言都基于基础的数组实现了动态数组，比如J">
<meta itemprop="datePublished" content="2021-07-18T21:14:55+08:00" />
<meta itemprop="dateModified" content="2022-01-04T16:19:03+08:00" />
<meta itemprop="wordCount" content="3459">



<meta itemprop="keywords" content="code,golang," />
<meta property="og:title" content="重学数据结构和算法" />
<meta property="og:description" content="常见数据结构 数组 数组的时间效率很高，但是空间效率很低，而且不安全，比如访问越界造成踩内存。 很多高级语言都基于基础的数组实现了动态数组，比如J" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cvvz.github.io/post/data-structure-and-algorithm/" />
<meta property="article:published_time" content="2021-07-18T21:14:55+08:00" />
<meta property="article:modified_time" content="2022-01-04T16:19:03+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="重学数据结构和算法"/>
<meta name="twitter:description" content="常见数据结构 数组 数组的时间效率很高，但是空间效率很低，而且不安全，比如访问越界造成踩内存。 很多高级语言都基于基础的数组实现了动态数组，比如J"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>重学数据结构和算法</title>
	<link rel="stylesheet" href="https://cvvz.github.io/css/style.min.7a1ec200e9f3394f73c6eda58011808507a3b24318de81e1e343f22a2470caef.css">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://cvvz.github.io">Vic&#39;s Blog</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://cvvz.github.io/post/">文章</a>
					<a href="https://cvvz.github.io/read/">读书</a>
					<a href="https://cvvz.github.io/about/">关于</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="目录"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/cvvz" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="mailto:ftdchenwz@gmail.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a></span><button id="menu-btn" class="hdr-btn" title="菜单"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://cvvz.github.io/post/">文章</a></li>
			<li><a href="https://cvvz.github.io/read/">读书</a></li>
			<li><a href="https://cvvz.github.io/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<h1>重学数据结构和算法</h1>
			</header>
			<div class="content">
				<h2 id="常见数据结构">常见数据结构<a href="#常见数据结构" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="数组">数组<a href="#数组" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>数组的时间效率很高，但是空间效率很低，而且不安全，比如访问越界造成踩内存。</p>
<p>很多高级语言都基于基础的数组实现了<strong>动态数组</strong>，比如Java中的ArrayList、C++ STL中的vector和golang中的slice，动态数组的优势在于可以动态扩容，使用起来很方便，<strong>在实现算法时更加handy</strong>。但是由于封装了额外的数据迁移等操作，时间效率上不如数组高。</p>
<p>🌟<strong>技巧：使用双指针求两数之和</strong></p>
<h3 id="链表">链表<a href="#链表" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h3 id="单链表双链表循环链表">单链表、双链表、循环链表<a href="#单链表双链表循环链表" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>🌟<strong>技巧：使用哨兵节点简化插入和删除节点的逻辑。</strong></p>
<blockquote>
<p>所有高级数据结构都是在数组和链表的基础上衍生出来的。</p>
</blockquote>
<h3 id="栈和队列">栈和队列<a href="#栈和队列" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>“操作受限”的线性表，只支持两种基本操作：push, pop。</p>
<p>递归的算法都可以用栈来实现。</p>
<blockquote>
<p>高性能定时器，除了可以用堆实现（<strong>比如golang的timer就是用最小四叉堆</strong>），还可以用<strong>环形队列</strong>，详见 <a href="https://zhuanlan.zhihu.com/p/65835110">时间轮算法 HashedWheelTimer</a> 、<a href="http://russellluo.com/2018/10/golang-implementation-of-hierarchical-timing-wheels.html">层级时间轮的 Golang 实现</a></p>
</blockquote>
<h3 id="hash表">hash表<a href="#hash表" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>高级语言内置了hash表，比如Java 中的 HashMap，golang中的map数据类型。</p>
<blockquote>
<p><strong>Java JDK中自带TreeMap</strong>，可以按 key 进行排序。</p>
<p>但是在 Go 语言的“简约设计”面前，这些都是不存在的——Go 只提供了最基础的 hash map。并且，在借助 range 关键字对 Go 的 map 进行遍历访问的时候，会对 map 的 key 的顺序做随机化处理，也就是说即使是同一个 map 在同一个程序里进行两次相同的遍历，前后两轮访问 key 的顺序也是随机化的。(可以在<a href="https://go.dev/play/p/LYJSbQBjWa6">这里</a>进行验证)。</p>
<p>我们可以自己实现，或者借助其他开源解决方案，比如<a href="https://github.com/emirpasic/gods">emirpasic/gods</a>。</p>
</blockquote>
<ol>
<li>
<p>hash表来源于<strong>数组</strong>，借助<strong>散列函数</strong>对数组这种数据结构进行扩展，也就是将key映射为数组下标index。</p>
</li>
<li>
<p>将key转化为数组下标的方法称为<strong>散列函数</strong>，散列函数的计算结果称为<strong>hash值</strong>。数据存储在<strong>hash值</strong>对应的<strong>数组下标</strong>位置。</p>
</li>
</ol>
<blockquote>
<p>实现hash表所使用的hash算法要求执行<strong>速度快</strong>，值是否能<strong>平均分布</strong>在各个槽中（比如简单的取模算法）。并不是很在乎<strong>安全性</strong>（是否能反向解密出原始数据）和<strong>hash冲突</strong>（哈希值相同）。所以不会使用<strong>加密用</strong>的哈希算法。</p>
<p>hash函数,有加密型和非加密型。加密型的一般用于加密数据、数字摘要等，典型代表就是md5、sha1、sha256、aes256 。非加密型的一般就是查找。</p>
</blockquote>
<h3 id="hash算法">hash算法<a href="#hash算法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><strong>hash算法在hash表中的应用就是散列函数。</strong></p>
<p><a href="https://time.geekbang.org/column/article/67388">在分布式系统中的应用</a>：</p>
<ol>
<li>负载均衡</li>
<li>数据分片</li>
<li>分布式存储（<strong>一致性哈希</strong>）</li>
</ol>
<blockquote>
<p>取模似乎是用的最多的一种哈希算法。MD5、SHA256等哈希算法，一般会用在把一个大的二进制文件转换为一个唯一的二进制数值。</p>
</blockquote>
<h3 id="树">树<a href="#树" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="二叉树">二叉树<a href="#二叉树" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>二叉树的遍历：
<ul>
<li>广度优先搜索：层序遍历</li>
<li>深度优先搜索：前中后序遍历。</li>
</ul>
<blockquote>
<p><strong>“前中后”指的是当前节点和左右子树谁先打印</strong></p>
</blockquote>
<ul>
<li>🌟深度搜索可以用栈或者递归，递归算法实现起来很简单，广度搜索只能用队列。🌟</li>
</ul>
</li>
<li>完全二叉树和满二叉树：可以用<strong>数组存储</strong>
<blockquote>
<p><strong>堆通常用完全二叉树实现。完全二叉树又可以用数组实现，因此堆也可以用数组实现。</strong></p>
</blockquote>
</li>
<li>二叉查找树：<strong>和有序数组的二分查找类比记忆</strong>
<blockquote>
<p><strong>中序遍历二叉搜索树可以得到一个有序数组</strong></p>
</blockquote>
</li>
<li>平衡二叉查找树：二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2n 的情况，从而导致各个操作的效率下降。<strong>极端情况下，二叉树会退化为链表</strong>，时间复杂度会退化到 O(n)。所以又发明了<strong>平衡二叉查找树</strong>。
<blockquote>
<p>“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p>
</blockquote>
</li>
<li><strong>红黑树是一种平衡二叉查找树</strong>。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。<strong>Java中的TreeMap可以对哈希表的key进行排序，底层就用到了红黑树</strong>。</li>
</ul>
<h4 id="堆httpsleetcode-cncomtagheap-priority-queueproblemset"><a href="https://leetcode-cn.com/tag/heap-priority-queue/problemset/">堆</a><a href="#堆httpsleetcode-cncomtagheap-priority-queueproblemset" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<blockquote>
<p><strong>堆通常用完全二叉树实现 -&gt; 完全二叉树又可以用数组实现 -&gt; 因此堆也可以用数组实现。</strong></p>
</blockquote>
<p><strong>堆的核心操作：</strong></p>
<ol start="0">
<li>核心中的核心：堆化（heapify）
<ol>
<li><strong>从上往下<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/container/heap/heap.go;l=101-119">down</a></strong></li>
<li><strong>从下往上<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/container/heap/heap.go;l=90-99">up</a></strong></li>
</ol>
</li>
<li>替换堆顶元素，然后从上往下堆化：<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/container/heap/heap.go;l=57-65">Pop</a></li>
<li>向堆尾添加元素：<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/container/heap/heap.go;l=50-55">Push</a>，并进行从下往上堆化</li>
<li>建堆：<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/container/heap/heap.go;l=42-48">Init</a></li>
</ol>
<p><a href="https://time.geekbang.org/column/article/70187"><strong>堆的应用</strong></a>:</p>
<ol>
<li>优先级队列
<ol>
<li>合并有序小文件</li>
<li>定时器</li>
</ol>
</li>
<li><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">数据流的中位数</a>、99线问题</li>
<li>TopK问题
<ol>
<li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">静态topK</a>
<blockquote>
<p>对于静态topK中的<strong>找出第K大元素</strong>的问题，如果数据量能够直接加载进内存，那么用快速排序思想求解会更快（O(n)）；堆排序会比快排更省内存，不过要一直读磁盘/网络，构造流数据，即动态topK</p>
</blockquote>
</li>
<li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">动态topK</a></li>
</ol>
</li>
</ol>
<h3 id="图">图<a href="#图" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><strong>有向无环图（DAG）的<a href="https://leetcode-cn.com/tag/topological-sort/problemset/">拓扑排序</a></strong></p>
<p><strong>数据结构（存储方法）</strong>：邻接矩阵（二位数组） 和 邻接表</p>
<ul>
<li><strong>邻接矩阵</strong>
<blockquote>
<p><strong>一般图的BFS、DFS、拓扑排序算法，以邻接矩阵（数组）的形式考察的比较的多；而二叉树的BFS、DFS则是以链表的形式考察。BFS要用到队列，DFS要用到栈。</strong>
🌟深度搜索可以用栈或者递归，递归算法实现起来很简单，广度搜索只能用队列。🌟</p>
</blockquote>
</li>
<li>邻接表</li>
</ul>
<h2 id="常见算法">常见算法<a href="#常见算法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="排序">排序<a href="#排序" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><strong>冒泡排序、插入排序、选择排序</strong>：三种O(n2)的<strong>简单无脑的</strong>算法，数据量不大时可以用一用。</p>
<p><strong>归并排序</strong>：不断二分，递归下去，然后“<strong>从下往上</strong>”merge。由于这个merge无法原地执行，因此空间复杂度为O(n)。</p>
<blockquote>
<p>虽然归并排序用到了递归，但是空间复杂度不是O(n2)，因为每次merge时，下面那一层的内存就被释放掉了。</p>
<p>归并排序是stable的，所以<strong>golang的<a href="https://github.com/golang/go/blob/master/src/sort/sort.go#L378-L404">sort.Stable</a>使用归并排序实现</strong>。</p>
</blockquote>
<p><strong>快速排序</strong>：选择一个pivot，然后“<strong>从上往下</strong>”不断进行<strong>原地的</strong>partition操作，由于partition是原地的，因此空间复杂度为O(1)。</p>
<blockquote>
<p><strong>快速排序的关键是原地partition</strong>
因为快速排序优化了内存使用，所以应用比归并排序要广泛。但是快速排序在最坏情况下的时间复杂度是 O(n2)，<strong>需要解决这个“复杂度恶化”的问题</strong>。这个问题的根因还是我们选择的分区点（pivot）不合理导致的，理想的分区点应该是左右两边的数据量差不多，最好能二分，这样递归的层次就最少。pivot的选择方法最常见的有两种：</p>
</blockquote>
<ol>
<li>三数取中法：选择三个或者更多的数，选择他们的中间值作为pivot。</li>
<li>随机法：从概率上说不会一直选的都是最差的点作为pivot。</li>
</ol>
<p><strong>归并排序</strong>和<strong>快速排序</strong>都用到了<strong>分治</strong>思想。</p>
<p>我们可以借鉴快排的思想，来解决非排序的问题，比如用O(n)的时间复杂度解决<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">静态topK</a>问题。</p>
<blockquote>
<p>事实上面试中快排相关的考点就是求一个数组中的第K大元素。<strong>注意是第K大，而不是前K大。前K大需要借助堆排序。</strong></p>
</blockquote>
<p><strong>堆排序</strong>：步骤分为</p>
<ol>
<li>建堆：堆化
<ol>
<li>方法一：<strong>从第一个非叶子结点开始</strong>，依次执行从上往下堆化</li>
<li>方法二：不断插入尾部，并对新插入节点执行从下往上堆化</li>
</ol>
</li>
<li>调整：不断交换堆顶和堆尾元素 + 重新堆化（从上往下）</li>
</ol>
<blockquote>
<p><strong>注意，在做堆排序时，由于调整这一步是从上往下堆化，所以建堆时应该用方法一，这样heapify函数才能复用。参考<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/sort/sort.go;l=66-81">heapSort</a></strong></p>
</blockquote>
<h3 id="搜索算法">搜索算法<a href="#搜索算法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><strong>广度优先搜索和深度优先搜索</strong>在算法面试中都是非常有用的工具，也就是说<strong>掌握BFS和DFS是基础要求</strong>，很多时候<strong>使用任意一种</strong>搜索算法就能解决某些与图相关的面试题。
<strong>🌟深度搜索可以用栈或者递归，递归算法实现起来很简单，广度搜索只能用队列。🌟</strong></p>
<p>如果面试题要求在无权图中找出两个节点之间的最短距离，那么广度优先搜索可能是更合适的算法。
如果面试题要求找出符合条件的路径，那么深度优先搜索可能是更合适的算法。</p>
<h3 id="二分查找">二分查找<a href="#二分查找" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>二分查找的<strong>三个容易出错的地方</strong>：</p>
<ul>
<li>循环退出条件</li>
<li>mid 的取值可能越界</li>
<li>low 和 high 的更新。</li>
</ul>
<p>二分查找可以用递归实现。</p>
<h2 id="基本算法思想">基本算法思想<a href="#基本算法思想" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="贪心httpsleetcode-cncomtaggreedyproblemset"><a href="https://leetcode-cn.com/tag/greedy/problemset/">贪心</a><a href="#贪心httpsleetcode-cncomtaggreedyproblemset" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<blockquote>
<p>严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。</p>
</blockquote>
<h3 id="分治httpsleetcode-cncomtagdivide-and-conquerproblemset"><a href="https://leetcode-cn.com/tag/divide-and-conquer/problemset/">分治</a><a href="#分治httpsleetcode-cncomtagdivide-and-conquerproblemset" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<blockquote>
<p>分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。</p>
<p>分治经常用在海量数据处理的场景下，内存无法直接装载全部数据，就将数据分批装载进内存处理，再将结果进行合并。（给1TB的订单排序）</p>
<p><strong>要判断清楚数据规模是不是可以直接装载进内存</strong>，比如获取10亿个整数第k大的数：10亿个整数 = 80亿Byte( int=64bit ) ≈（不足）8GB，这个时候要考虑单机的实际可用内存大小是否可以直接装载8GB。如果能直接装进去，那么可以用快排思想做；如果不能直接装进去，那么构造大小为k的堆，然后从文件读数据进行处理。
还有的时候如果文件太大，那么需要进行<strong>数据分片</strong>，分成若干个小文件以后，再分而治之，即逐个处理可以直接载入内存的小文件，最后合并得到结果。</p>
</blockquote>
<h3 id="动态规划httpsleetcode-cncomtagdynamic-programmingproblemset"><a href="https://leetcode-cn.com/tag/dynamic-programming/problemset/">动态规划</a><a href="#动态规划httpsleetcode-cncomtagdynamic-programmingproblemset" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<blockquote>
<p>DP的主要学习难点跟递归类似，那就是，求解问题的过程不太符合人类常规的思维方式。</p>
</blockquote>
<h3 id="回溯httpsleetcode-cncomtagbacktrackingproblemset"><a href="https://leetcode-cn.com/tag/backtracking/problemset/">回溯</a><a href="#回溯httpsleetcode-cncomtagbacktrackingproblemset" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<blockquote>
<p>DFS利用的就是回溯算法思想。</p>
</blockquote>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://cvvz.github.io/tags/code">code</a></span><span class="tag"><a href="https://cvvz.github.io/tags/golang">golang</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>3459 字</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="20" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-git-commit"><circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line></svg><a href="https://github.com/cvvz/blog/commit/2bcaf13af0c90b568bd1c7e46a5ec6a6c85f13b2" target="_blank" rel="noopener">2bcaf13</a> @ 2022-01-04</p>
			</footer>
		</article>
		<aside id="toc" class="show-toc">
			<div class="toc-title">目录</div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#常见数据结构">常见数据结构</a>
      <ul>
        <li><a href="#数组">数组</a></li>
        <li><a href="#链表">链表</a></li>
        <li><a href="#单链表双链表循环链表">单链表、双链表、循环链表</a></li>
        <li><a href="#栈和队列">栈和队列</a></li>
        <li><a href="#hash表">hash表</a></li>
        <li><a href="#hash算法">hash算法</a></li>
        <li><a href="#树">树</a></li>
        <li><a href="#图">图</a></li>
      </ul>
    </li>
    <li><a href="#常见算法">常见算法</a>
      <ul>
        <li><a href="#排序">排序</a></li>
        <li><a href="#搜索算法">搜索算法</a></li>
        <li><a href="#二分查找">二分查找</a></li>
      </ul>
    </li>
    <li><a href="#基本算法思想">基本算法思想</a>
      <ul>
        <li><a href="#贪心httpsleetcode-cncomtaggreedyproblemset"><a href="https://leetcode-cn.com/tag/greedy/problemset/">贪心</a></a></li>
        <li><a href="#分治httpsleetcode-cncomtagdivide-and-conquerproblemset"><a href="https://leetcode-cn.com/tag/divide-and-conquer/problemset/">分治</a></a></li>
        <li><a href="#动态规划httpsleetcode-cncomtagdynamic-programmingproblemset"><a href="https://leetcode-cn.com/tag/dynamic-programming/problemset/">动态规划</a></a></li>
        <li><a href="#回溯httpsleetcode-cncomtagbacktrackingproblemset"><a href="https://leetcode-cn.com/tag/backtracking/problemset/">回溯</a></a></li>
      </ul>
    </li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="https://cvvz.github.io/post/the-difficulty-of-distributed-db-on-cloud/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;新</span><br><span>分布式数据库上k8s面临的困境</span>
			</a>
			<a class="prev-post" href="https://cvvz.github.io/post/design-pattern/">
				<span class="post-nav-label">旧&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>重学设计模式</span>
			</a>
		</div>
		<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
        <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
		<div id="gitalk-container" class="thin"></div>     
		<script type="text/javascript">
			var gitalk = new Gitalk({
				clientID: '0f8bdcbe6b4973f9b206',
				clientSecret: '4939e64d59c93fc5eb7eaf74469a746e4535700d',
				repo: 'cvvz.github.io',
				owner: 'cvvz',
				admin: ['cvvz'],
				id: location.pathname,      
				distractionFreeMode: true 
			});
  			gitalk.render('gitalk-container');
		</script>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2022 <a href="https://cvvz.github.io">陈维志</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://cvvz.github.io/post/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://cvvz.github.io/js/main.min.784417f5847151f848c339cf0acb13a06cbb648b1483435a28ed4556c4ead69b.js"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-M8Q3DKDEVL', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
