<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="google-site-verification" content="Wp3QtEkIlF0ZvtKx90lPmoXyH39d-pmBhiTyTbba9L4" />
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta itemprop="name" content="基于ARM7分析函数调用栈">
<meta itemprop="description" content="寄存器 分析函数调用栈要用到的几个特殊用途寄存器： ARM X86 用途 r11(fp) rbp/ebp 栈帧指针 r13(sp) rsp/esp 栈顶指针 r14(lr) N/A 返回地址 r15(pc) rip 指令指针 栈帧内容 如下图（《程序员的自我修养》">
<meta itemprop="datePublished" content="2019-09-03T18:44:12+08:00" />
<meta itemprop="dateModified" content="2019-09-03T18:44:12+08:00" />
<meta itemprop="wordCount" content="2027">



<meta itemprop="keywords" content="Linux," />
<meta property="og:title" content="基于ARM7分析函数调用栈" />
<meta property="og:description" content="寄存器 分析函数调用栈要用到的几个特殊用途寄存器： ARM X86 用途 r11(fp) rbp/ebp 栈帧指针 r13(sp) rsp/esp 栈顶指针 r14(lr) N/A 返回地址 r15(pc) rip 指令指针 栈帧内容 如下图（《程序员的自我修养》" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cvvz.github.io/post/call-stack/" />
<meta property="article:published_time" content="2019-09-03T18:44:12+08:00" />
<meta property="article:modified_time" content="2019-09-03T18:44:12+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="基于ARM7分析函数调用栈"/>
<meta name="twitter:description" content="寄存器 分析函数调用栈要用到的几个特殊用途寄存器： ARM X86 用途 r11(fp) rbp/ebp 栈帧指针 r13(sp) rsp/esp 栈顶指针 r14(lr) N/A 返回地址 r15(pc) rip 指令指针 栈帧内容 如下图（《程序员的自我修养》"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>基于ARM7分析函数调用栈</title>
	<link rel="stylesheet" href="https://cvvz.github.io/css/style.min.052d306dd1c49415658027c566de932b0e3c2d1278df9f6b44487a95c9b6c1ee.css">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://cvvz.github.io">Vic&#39;s Blog</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://cvvz.github.io/post/">文章</a>
					<a href="https://cvvz.github.io/about/">关于</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/cvvz" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="mailto:ftdchenwz@gmail.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a></span><button id="menu-btn" class="hdr-btn" title="菜单"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://cvvz.github.io/post/">文章</a></li>
			<li><a href="https://cvvz.github.io/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<h1>基于ARM7分析函数调用栈</h1>
			</header>
			<div class="content">
				<h2 id="寄存器">寄存器<a href="#寄存器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>分析函数调用栈要用到的几个特殊用途寄存器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ARM</th>
<th style="text-align:center">X86</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><!-- raw HTML omitted -->r11(fp)<!-- raw HTML omitted --></td>
<td style="text-align:center">rbp/ebp</td>
<td style="text-align:center">栈帧指针</td>
</tr>
<tr>
<td style="text-align:center">r13(sp)</td>
<td style="text-align:center">rsp/esp</td>
<td style="text-align:center">栈顶指针</td>
</tr>
<tr>
<td style="text-align:center">r14(lr)</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">返回地址</td>
</tr>
<tr>
<td style="text-align:center">r15(pc)</td>
<td style="text-align:center">rip</td>
<td style="text-align:center">指令指针</td>
</tr>
</tbody>
</table>
<h2 id="栈帧内容">栈帧内容<a href="#栈帧内容" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>如下图（《程序员的自我修养》图10-4）所示：</p>
<figure>
    <img src="/%e6%a0%88.jpg" width="500px"/> 
</figure>

<p>图中栈帧指针指向的内存中保存的是上一个栈的栈帧指针，这是X86的情形。在分析ARM的函数栈时发现，ARM的栈帧指针指向的是函数返回地址。</p>
<h2 id="入栈">入栈<a href="#入栈" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>调用函数时，首先压栈的是参数，且从右向左依次压栈；接着压入返回地址；接着被调函数执行“标准开头”：</p>
<pre><code class="language-x86asm" data-lang="x86asm">push rbp
mov rbp rsp
</code></pre><p>首先rbp入栈；rbp入栈后，rsp自动加8（64位），rsp此时指向的栈顶即存放rbp的栈帧；接着令%rbp=%rsp，即使得rbp指向存放着上一个栈的rbp的内存。</p>
<p>而ARM（32位）的“标准开头”长这样：</p>
<pre><code class="language-armasm" data-lang="armasm">push {fp, lr}
add fp, sp, #4
</code></pre><p>也是先将返回地址(lr)入栈，然后栈帧指针(fp)入栈，但是接着是令%fp=%sp+4，即使fp指向存放返回地址的内存。</p>
<p>不论栈帧指针指向的是上一个栈帧指针，还是返回地址，都能通过函数的栈帧指针偏移找到其调用函数的地址，根据栈帧指针的链式关系，可以回溯出整个函数的调用关系。</p>
<p>GCC的编译选项<code>--fomit-frame-pointer</code>可以取消使用帧指针。一般帧指针可以方便的定位函数的局部变量、参数、返回地址，取消帧指针后则使用栈指针顶进行定位。这么做的好处是可以多出一个寄存器供使用，程序运行速度更快，但是没有帧指针之后，无法方便的使用GDB进行调试。</p>
<h3 id="出栈">出栈<a href="#出栈" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>出栈与入栈动作刚好相反，对于X86，“标准结尾”如下：</p>
<pre><code class="language-x86asm" data-lang="x86asm">leaveq 
retq 
</code></pre><p>leaveq实际上是两条指令：</p>
<pre><code class="language-x86asm" data-lang="x86asm">movq %rbp, %rsp
popq %rbp
</code></pre><p>先将rbp地址赋给rsp，栈顶此时指向的内存存放的是上一个栈的rbp，然后弹出栈顶的数据到rbp中，即rbp指向上一个栈的栈底，出栈动作导致rsp自增，于是rsp此时指向的内存中存放函数返回地址；</p>
<p>retq则将栈顶地址pop到rip，即rip此时指向函数退出后的下一条指令，rsp则指向上一个栈的栈顶。这三个动作做完后，rsp、rbp、rip恢复到调用函数以前的现场。</p>
<p>ARM的行为和X86基本一致，“标准结尾”如下：</p>
<pre><code class="language-armasm" data-lang="armasm">sub sp, fp, #4
pop {fp, pc}
</code></pre><h1 id="基于arm7分析一个简单的函数调用栈">基于ARM7分析一个简单的函数调用栈<a href="#基于arm7分析一个简单的函数调用栈" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>示例代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">test2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>
	<span class="n">ii</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">test</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
	<span class="n">test2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="函数调用过程入栈">函数调用过程（入栈）<a href="#函数调用过程入栈" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>将断点打在main函数调用test之前：</p>
<pre><code class="language-armasm" data-lang="armasm">(gdb) b *0x000104bc
Breakpoint 2 at 0x104bc: file main.c, line 21.
(gdb) disassemble /m main
Dump of assembler code for function main:
18	{
   0x000104a0 &lt;+0&gt;:	push	{r11, lr}
   0x000104a4 &lt;+4&gt;:	add	r11, sp, #4
   0x000104a8 &lt;+8&gt;:	sub	sp, sp, #8

19		char c = 'a';
   0x000104ac &lt;+12&gt;:	mov	r3, #97	; 0x61
   0x000104b0 &lt;+16&gt;:	strb	r3, [r11, #-5]

20		char ret;
21		ret = test(c);
   0x000104b4 &lt;+20&gt;:	ldrb	r3, [r11, #-5]
   0x000104b8 &lt;+24&gt;:	mov	r0, r3
=&gt; 0x000104bc &lt;+28&gt;:	bl	0x10468 &lt;test&gt;
   0x000104c0 &lt;+32&gt;:	mov	r3, r0
   0x000104c4 &lt;+36&gt;:	strb	r3, [r11, #-6]

22		return 0;
   0x000104c8 &lt;+40&gt;:	mov	r3, #0

23	}
   0x000104cc &lt;+44&gt;:	mov	r0, r3
   0x000104d0 &lt;+48&gt;:	sub	sp, r11, #4
   0x000104d4 &lt;+52&gt;:	pop	{r11, pc}

End of assembler dump.
</code></pre><p>此时栈帧指针和栈顶指针的值：</p>
<pre><code class="language-armasm" data-lang="armasm">(gdb) i r r11 sp
r11            0x7efffaec	2130705132
sp             0x7efffae0	0x7efffae0
(gdb) x /xw 0x7efffaec
0x7efffaec:	0x76e8f678
(gdb) info symbol 0x76e8f678
__libc_start_main + 276 in section .text of /lib/arm-linux-gnueabihf/libc.so.6
</code></pre><p>可以看到，栈帧指向的返回地址是__libc_start_main + 276，即main函数是由__libc_start_main调用的，由前面分析得知，栈指针-4地址处存放的是上一个函数的栈指针，查看可以发现其值为0：</p>
<pre><code class="language-armasm" data-lang="armasm">(gdb) x /xw 0x7efffaec-4
0x7efffae8:	0x00000000
</code></pre><p>因此__libc_start_main是所有函数的起点。</p>
<p>接着执行调用test指令：</p>
<pre><code class="language-armasm" data-lang="armasm">(gdb) si
test (c=0 '\000') at main.c:10
10	{
(gdb) disassemble 
Dump of assembler code for function test:
=&gt; 0x00010468 &lt;+0&gt;:	push	{r11, lr}
   0x0001046c &lt;+4&gt;:	add	r11, sp, #4
   0x00010470 &lt;+8&gt;:	sub	sp, sp, #16
   0x00010474 &lt;+12&gt;:	mov	r3, r0
   0x00010478 &lt;+16&gt;:	strb	r3, [r11, #-13]
   0x0001047c &lt;+20&gt;:	ldrb	r3, [r11, #-13]
   0x00010480 &lt;+24&gt;:	mov	r0, r3
   0x00010484 &lt;+28&gt;:	bl	0x10300 &lt;putchar@plt&gt;
   0x00010488 &lt;+32&gt;:	ldr	r0, [r11, #-8]
   0x0001048c &lt;+36&gt;:	bl	0x10440 &lt;test2&gt;
   0x00010490 &lt;+40&gt;:	ldrb	r3, [r11, #-13]
   0x00010494 &lt;+44&gt;:	mov	r0, r3
   0x00010498 &lt;+48&gt;:	sub	sp, r11, #4
   0x0001049c &lt;+52&gt;:	pop	{r11, pc}
End of assembler dump.
(gdb) i r $lr
lr             0x104c0	66752
(gdb) info symbol $lr
main + 32 in section .text of /root/main
</code></pre><p>可以看到此时lr寄存器中保存的指令即调用test后的下一条指令。继续向下执行：</p>
<pre><code class="language-armasm" data-lang="armasm">(gdb) ni
0x0001046c	10	{
(gdb) i r r11 sp
r11            0x7efffaec	2130705132
sp             0x7efffad8	0x7efffad8
</code></pre><p>观察到将r11和lr入栈后，sp减少了8字节，不难猜测，高4字节存放了lr的值（返回地址），低4字节存放了sp的值（上一个栈的栈帧指针）：</p>
<pre><code class="language-armasm" data-lang="armasm">(gdb) x /xw 0x7efffad8
0x7efffad8:	0x7efffaec
(gdb) x /xw 0x7efffadc
0x7efffadc:	0x000104c0
(gdb) i r $lr $r11
lr             0x104c0	66752
r11            0x7efffaec	2130705132
</code></pre><p>继续执行：</p>
<pre><code class="language-armasm" data-lang="armasm">(gdb) ni
0x00010470	10	{
(gdb) i r $r11
r11            0x7efffadc	2130705116
</code></pre><p>此时r11指向的是函数返回地址，而不是像x86一样指向上一个栈帧指针。</p>
<h2 id="函数返回过程出栈">函数返回过程（出栈）<a href="#函数返回过程出栈" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>观察test的汇编指令：</p>
<pre><code class="language-armasm" data-lang="armasm">(gdb) disassemble /m test
Dump of assembler code for function test:
10	{
   0x00010468 &lt;+0&gt;:	push	{r11, lr}
   0x0001046c &lt;+4&gt;:	add	r11, sp, #4
   0x00010470 &lt;+8&gt;:	sub	sp, sp, #16
   0x00010474 &lt;+12&gt;:	mov	r3, r0
   0x00010478 &lt;+16&gt;:	strb	r3, [r11, #-13]

11		int i;
12		printf(&quot;%c&quot;,c);
   0x0001047c &lt;+20&gt;:	ldrb	r3, [r11, #-13]
   0x00010480 &lt;+24&gt;:	mov	r0, r3
   0x00010484 &lt;+28&gt;:	bl	0x10300 &lt;putchar@plt&gt;

13		test2(i);
   0x00010488 &lt;+32&gt;:	ldr	r0, [r11, #-8]
   0x0001048c &lt;+36&gt;:	bl	0x10440 &lt;test2&gt;

14		return c;
   0x00010490 &lt;+40&gt;:	ldrb	r3, [r11, #-13]

15	}
   0x00010494 &lt;+44&gt;:	mov	r0, r3
=&gt; 0x00010498 &lt;+48&gt;:	sub	sp, r11, #4
   0x0001049c &lt;+52&gt;:	pop	{r11, pc}

End of assembler dump.
</code></pre><p>可以发现在第三步<code>sub	sp, sp, #16</code>通过移动栈顶指针为函数分配16字节的栈空间后，整个函数执行过程中栈帧指针r11和栈顶指针sp的位置就固定不变了。函数运行完毕进入出栈流程时，首先通过<code>sub	sp, r11, #4</code>将栈顶指针指向上一个栈帧指针，接着<code>pop	{r11, pc}</code>依次出栈，将上一个栈帧指针赋值给r11，再将返回地址赋值给pc，两次pop后，栈顶指针往栈底方向退两次，最终使得栈顶指针和栈底指针都还原成main调用test前的样子：</p>
<pre><code class="language-armasm" data-lang="armasm">(gdb) disassemble 
Dump of assembler code for function main:
   0x000104a0 &lt;+0&gt;:	push	{r11, lr}
   0x000104a4 &lt;+4&gt;:	add	r11, sp, #4
   0x000104a8 &lt;+8&gt;:	sub	sp, sp, #8
   0x000104ac &lt;+12&gt;:	mov	r3, #97	; 0x61
   0x000104b0 &lt;+16&gt;:	strb	r3, [r11, #-5]
   0x000104b4 &lt;+20&gt;:	ldrb	r3, [r11, #-5]
   0x000104b8 &lt;+24&gt;:	mov	r0, r3
   0x000104bc &lt;+28&gt;:	bl	0x10468 &lt;test&gt;
=&gt; 0x000104c0 &lt;+32&gt;:	mov	r3, r0
   0x000104c4 &lt;+36&gt;:	strb	r3, [r11, #-6]
   0x000104c8 &lt;+40&gt;:	mov	r3, #0
   0x000104cc &lt;+44&gt;:	mov	r0, r3
   0x000104d0 &lt;+48&gt;:	sub	sp, r11, #4
   0x000104d4 &lt;+52&gt;:	pop	{r11, pc}
End of assembler dump.
(gdb) i r r11 sp pc
r11            0x7efffaec	2130705132
sp             0x7efffae0	0x7efffae0
pc             0x104c0	0x104c0 &lt;main+32&gt;
</code></pre>
			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://cvvz.github.io/tags/linux">Linux</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>2027 字</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="prev-post" href="https://cvvz.github.io/post/about-computer-security/">
				<span class="post-nav-label">旧&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>安全知识总结</span>
			</a>
		</div>
		<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
        <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
		<div id="gitalk-container" class="thin"></div>     
		<script type="text/javascript">
			var gitalk = new Gitalk({
				clientID: '0f8bdcbe6b4973f9b206',
				clientSecret: '4939e64d59c93fc5eb7eaf74469a746e4535700d',
				repo: 'cvvz.github.io',
				owner: 'cvvz',
				admin: ['cvvz'],
				id: location.pathname,      
				distractionFreeMode: true 
			});
  			gitalk.render('gitalk-container');
		</script>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 <a href="https://cvvz.github.io">陈维志</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://cvvz.github.io/post/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://cvvz.github.io/js/main.min.784417f5847151f848c339cf0acb13a06cbb648b1483435a28ed4556c4ead69b.js"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-M8Q3DKDEVL', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
